#!/usr/bin/env node
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const repoRoot = path.resolve(__dirname, '..');
const protoRoot = path.join(repoRoot, 'libs', 'common', 'src', 'proto');
const outFile = path.join(protoRoot, 'index.ts');

function walk(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  let files = [];
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) files = files.concat(walk(full));
    else if (e.isFile() && e.name.endsWith('.ts') && !e.name.endsWith('.d.ts') && e.name !== 'index.ts') {
      files.push(full);
    }
  }
  return files;
}

if (!fs.existsSync(protoRoot)) {
  console.error('proto directory not found at', protoRoot);
  process.exit(1);
}

const files = walk(protoRoot);

// collect exports grouped by import path to emit single grouped statements
const exportsByPath = new Map(); // importPath -> { types: Set, values: Set }
// map package string -> alias export info (only one export per unique package value)
const protoPkgMap = new Map();

for (const f of files) {
  const content = fs.readFileSync(f, 'utf8');
  const rel = path.relative(protoRoot, f).replace(/\\/g, '/').replace(/\.ts$/, '');
  const importPath = `./${rel}`;

  // collect interface and type names
  const interfaceRegex = /export\s+interface\s+(\w+)/g;
  const typeRegex = /export\s+type\s+(\w+)/g;
  const enumRegex = /export\s+enum\s+(\w+)/g;
  const constRegex = /export\s+const\s+(\w+)/g;
  const funcRegex = /export\s+function\s+(\w+)/g;
  let m;
  const typeNames = [];
  const enumNames = [];
  const constNames = [];
  const funcNames = [];

  while ((m = interfaceRegex.exec(content))) typeNames.push(m[1]);
  while ((m = typeRegex.exec(content))) typeNames.push(m[1]);
  while ((m = enumRegex.exec(content))) enumNames.push(m[1]);
  while ((m = constRegex.exec(content))) constNames.push(m[1]);
  while ((m = funcRegex.exec(content))) funcNames.push(m[1]);

  // filter out helper/generic utility types generated by ts-proto
  const typeBlacklist = new Set(['DeepPartial', 'Exact', 'MessageFns']);
  let filteredTypeNames = typeNames.filter(n => !typeBlacklist.has(n));
    // prepare grouped export entry for this importPath
    if (!exportsByPath.has(importPath)) exportsByPath.set(importPath, { types: new Set(), values: new Set() });
    const entry = exportsByPath.get(importPath);

    // add enum names to values
    for (const e of enumNames) entry.values.add(e);

    // add consts and functions to values (exclude protobufPackage here)
    for (const c of constNames) if (c !== 'protobufPackage') entry.values.add(c);
    for (const fn of funcNames) entry.values.add(fn);

    // don't export a type if the same name is exported as a value (avoid duplicate identifier)
    if (filteredTypeNames.length) {
      filteredTypeNames = filteredTypeNames.filter(n => !entry.values.has(n));
    }

    // add remaining types to types set
    for (const t of filteredTypeNames) entry.types.add(t);

  // protobufPackage const: extract its string value and register a canonical alias per unique value
  const protoPkgValueMatch = content.match(/export\s+const\s+protobufPackage\s*=\s*(['"])([^'"\\]+)\1/);
  if (protoPkgValueMatch) {
    const pkgValue = protoPkgValueMatch[2];
    if (!protoPkgMap.has(pkgValue)) {
      // derive canonical alias based on top-level folder structure
      // examples:
      // - common/* -> PROTOBUF_COMMON_PACKAGE
      // - events/* -> PROTOBUF_EVENTS_PACKAGE
      // - services/risk_manager -> PROTOBUF_SERVICES_RISK_MANAGER_PACKAGE
      const parts = rel.split('/');
      let alias;
      if (parts[0] === 'common') alias = 'PROTOBUF_COMMON_PACKAGE';
      else if (parts[0] === 'events') alias = 'PROTOBUF_EVENTS_PACKAGE';
      else if (parts[0] === 'services' && parts[1]) {
        const svc = parts[1].replace(/[^a-zA-Z0-9]+/g, '_').toUpperCase();
        alias = `PROTOBUF_SERVICES_${svc}_PACKAGE`;
      } else {
        // fallback to package-derived alias
        const aliasBase = pkgValue.replace(/[^a-zA-Z0-9]+/g, '_').toUpperCase();
        alias = `PROTOBUF_${aliasBase}_PACKAGE`;
      }
      // store first importPath encountered for this package value
      protoPkgMap.set(pkgValue, { alias, importPath });
    }
  }
}

const header = `// Auto-generated proto index. Do not edit.\n// Generated by scripts/generate-proto-barrel.mjs\n\n`;
const pieces = [header];

// inject protobufPackage aliases into the grouped exports (use the importPath stored earlier)
for (const { alias, importPath } of protoPkgMap.values()) {
  if (!exportsByPath.has(importPath)) exportsByPath.set(importPath, { types: new Set(), values: new Set() });
  const entry = exportsByPath.get(importPath);
  entry.values.add(`protobufPackage as ${alias}`);
}

// Emit grouped exports per import path in discovery order
for (const [importPath, entry] of exportsByPath) {
  if (entry.types.size) {
    const typesArr = Array.from(entry.types);
    if (typesArr.join(', ').length > 40 || typesArr.length > 2) {
      pieces.push(`export type {`);
      for (const t of typesArr) pieces.push(`  ${t},`);
      pieces.push(`} from '${importPath}';`);
    } else {
      pieces.push(`export type { ${typesArr.join(', ')} } from '${importPath}';`);
    }
    pieces.push('');
  }
  if (entry.values.size) {
    const vals = Array.from(entry.values);
    if (vals.join(', ').length > 60 || vals.length > 3) {
      pieces.push('export {');
      for (const v of vals) pieces.push(`  ${v},`);
      pieces.push(`} from '${importPath}';`);
    } else {
      pieces.push(`export { ${vals.join(', ')} } from '${importPath}';`);
    }
    pieces.push('');
  }
}

// Also embed grpc constants (derived from repo proto files) directly into the barrel
try {
  const protoSearchRoot = path.join(repoRoot, 'proto');
  const protoFiles = [];
  if (fs.existsSync(protoSearchRoot)) {
    (function walkProto(dir) {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      for (const e of entries) {
        const full = path.join(dir, e.name);
        if (e.isDirectory()) walkProto(full);
        else if (e.isFile() && e.name.endsWith('.proto')) protoFiles.push(full);
      }
    })(protoSearchRoot);
  }

  if (protoFiles.length) {
    pieces.push('');
    pieces.push('// Auto-generated grpc constants (inlined).');
    pieces.push(`export const PROTO_FOLDER = 'proto';`);
    pieces.push('');

    for (const p of protoFiles) {
      const rel = path.relative(repoRoot, p).replace(/\\/g, '/'); // e.g. proto/services/prediction_engine.proto
      const relNoExt = rel.replace(/\.proto$/, '');
      const parts = relNoExt.split('/');
      const fileBase = parts[parts.length - 1];
      const upperBase = fileBase.replace(/[^a-zA-Z0-9]+/g, '_').toUpperCase();

      // proto file constant name
      let protoConstName;
      if (parts[0] === 'proto' && parts[1] === 'services') {
        protoConstName = `${upperBase}_PROTO`;
      } else {
        const tail = parts.slice(1).join('_').replace(/[^a-zA-Z0-9]+/g, '_').toUpperCase();
        protoConstName = `${tail}_PROTO`;
      }
      pieces.push(`export const ${protoConstName} = '${rel}';`);

      // For services, also export a CLIENT constant (name same as upperBase + _CLIENT)
      if (parts[0] === 'proto' && parts[1] === 'services') {
        const clientName = `${upperBase}_CLIENT`;
        pieces.push(`export const ${clientName} = '${clientName}';`);
      }

      pieces.push('');
    }
  }
} catch (e) {
  console.error('Failed to inline grpc constants:', e.message || e);
}

const outLines = pieces.join('\n');

fs.mkdirSync(path.dirname(outFile), { recursive: true });
// replace file if exists to ensure updates apply
try { fs.unlinkSync(outFile); } catch (e) { /* ignore */ }
fs.writeFileSync(outFile, outLines, 'utf8');
// compute counts for logging
let typeCount = 0;
let valueCount = 0;
for (const entry of exportsByPath.values()) {
  typeCount += entry.types.size;
  valueCount += entry.values.size;
}
console.log('Wrote', outFile, '(', typeCount, 'type exports,', valueCount, 'value exports,', protoPkgMap.size, 'unique protobufPackage exports, inlined grpc constants )');
