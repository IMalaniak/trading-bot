#!/usr/bin/env node
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const repoRoot = path.resolve(__dirname, '..');
const protoRoot = path.join(repoRoot, 'libs', 'common', 'src', 'proto');
const outFile = path.join(protoRoot, 'index.ts');

function walk(dir) {
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  let files = [];
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) files = files.concat(walk(full));
    else if (e.isFile() && e.name.endsWith('.ts') && !e.name.endsWith('.d.ts') && e.name !== 'index.ts') {
      files.push(full);
    }
  }
  return files;
}

if (!fs.existsSync(protoRoot)) {
  console.error('proto directory not found at', protoRoot);
  process.exit(1);
}

const files = walk(protoRoot);

const typeExports = [];
const valueExports = [];
// map package string -> alias export info (only one export per unique package value)
const protoPkgMap = new Map();

for (const f of files) {
  const content = fs.readFileSync(f, 'utf8');
  const rel = path.relative(protoRoot, f).replace(/\\/g, '/').replace(/\.ts$/, '');
  const importPath = `./${rel}`;

  // collect interface and type names
  const interfaceRegex = /export\s+interface\s+(\w+)/g;
  const typeRegex = /export\s+type\s+(\w+)/g;
  const enumRegex = /export\s+enum\s+(\w+)/g;
  let m;
  const typeNames = [];
  const enumNames = [];

  while ((m = interfaceRegex.exec(content))) typeNames.push(m[1]);
  while ((m = typeRegex.exec(content))) typeNames.push(m[1]);
  while ((m = enumRegex.exec(content))) enumNames.push(m[1]);

  if (typeNames.length) {
    if (typeNames.join(', ').length > 40 || typeNames.length > 2) {
      // multiline style
      typeExports.push([
        `export type {`,
        `  ${typeNames.join(',\n  ')},`,
        `} from '${importPath}';`,
      ].join('\n'));
    } else {
      typeExports.push(`export type { ${typeNames.join(', ')} } from '${importPath}';`);
    }
  }
  if (enumNames.length) valueExports.push(`export { ${enumNames.join(', ')} } from '${importPath}';`);

  // protobufPackage const: extract its string value and register a canonical alias per unique value
  const protoPkgValueMatch = content.match(/export\s+const\s+protobufPackage\s*=\s*(['"])([^'"\\]+)\1/);
  if (protoPkgValueMatch) {
    const pkgValue = protoPkgValueMatch[2];
    if (!protoPkgMap.has(pkgValue)) {
      // derive canonical alias based on top-level folder structure
      // examples:
      // - common/* -> PROTOBUF_COMMON_PACKAGE
      // - events/* -> PROTOBUF_EVENTS_PACKAGE
      // - services/risk_manager -> PROTOBUF_SERVICES_RISK_MANAGER_PACKAGE
      const parts = rel.split('/');
      let alias;
      if (parts[0] === 'common') alias = 'PROTOBUF_COMMON_PACKAGE';
      else if (parts[0] === 'events') alias = 'PROTOBUF_EVENTS_PACKAGE';
      else if (parts[0] === 'services' && parts[1]) {
        const svc = parts[1].replace(/[^a-zA-Z0-9]+/g, '_').toUpperCase();
        alias = `PROTOBUF_SERVICES_${svc}_PACKAGE`;
      } else {
        // fallback to package-derived alias
        const aliasBase = pkgValue.replace(/[^a-zA-Z0-9]+/g, '_').toUpperCase();
        alias = `PROTOBUF_${aliasBase}_PACKAGE`;
      }
      // store first importPath encountered for this package value
      protoPkgMap.set(pkgValue, { alias, importPath });
    }
  }
}

const header = `// Auto-generated proto index. Do not edit.\n// Generated by scripts/generate-proto-barrel.mjs\n\n`;
const pieces = [header];

// preserve discovery order for exports; append type exports, then value exports, then one alias export per unique package
for (const t of typeExports) pieces.push(t, '');
for (const v of valueExports) pieces.push(v);
if (valueExports.length) pieces.push('');
for (const { alias, importPath } of protoPkgMap.values()) pieces.push(`export { protobufPackage as ${alias} } from '${importPath}';`);

// Also embed grpc constants (derived from repo proto files) directly into the barrel
try {
  const protoSearchRoot = path.join(repoRoot, 'proto');
  const protoFiles = [];
  if (fs.existsSync(protoSearchRoot)) {
    (function walkProto(dir) {
      const entries = fs.readdirSync(dir, { withFileTypes: true });
      for (const e of entries) {
        const full = path.join(dir, e.name);
        if (e.isDirectory()) walkProto(full);
        else if (e.isFile() && e.name.endsWith('.proto')) protoFiles.push(full);
      }
    })(protoSearchRoot);
  }

  if (protoFiles.length) {
    pieces.push('');
    pieces.push('// Auto-generated grpc constants (inlined).');
    pieces.push(`export const PROTO_FOLDER = 'proto';`);
    pieces.push('');

    for (const p of protoFiles) {
      const rel = path.relative(repoRoot, p).replace(/\\/g, '/'); // e.g. proto/services/prediction_engine.proto
      const relNoExt = rel.replace(/\.proto$/, '');
      const parts = relNoExt.split('/');
      const fileBase = parts[parts.length - 1];
      const upperBase = fileBase.replace(/[^a-zA-Z0-9]+/g, '_').toUpperCase();

      // proto file constant name
      let protoConstName;
      if (parts[0] === 'proto' && parts[1] === 'services') {
        protoConstName = `${upperBase}_PROTO`;
      } else {
        const tail = parts.slice(1).join('_').replace(/[^a-zA-Z0-9]+/g, '_').toUpperCase();
        protoConstName = `${tail}_PROTO`;
      }
      pieces.push(`export const ${protoConstName} = '${rel}';`);

      // For services, also export a CLIENT constant (name same as upperBase + _CLIENT)
      if (parts[0] === 'proto' && parts[1] === 'services') {
        const clientName = `${upperBase}_CLIENT`;
        pieces.push(`export const ${clientName} = '${clientName}';`);
      }

      pieces.push('');
    }
  }
} catch (e) {
  console.error('Failed to inline grpc constants:', e.message || e);
}

const outLines = pieces.join('\n');

fs.mkdirSync(path.dirname(outFile), { recursive: true });
// replace file if exists to ensure updates apply
try { fs.unlinkSync(outFile); } catch (e) { /* ignore */ }
fs.writeFileSync(outFile, outLines, 'utf8');
console.log('Wrote', outFile, '(', typeExports.length, 'type exports,', valueExports.length, 'value exports,', protoPkgMap.size, 'unique protobufPackage exports, inlined grpc constants )');
